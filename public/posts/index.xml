<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Boyoon&#39;s blog</title>
    <link>https://boyoon-c.github.io/posts/</link>
    <description>Recent content in Posts on Boyoon&#39;s blog</description>
    <image>
      <title>Boyoon&#39;s blog</title>
      <url>https://boyoon-c.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://boyoon-c.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 25 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://boyoon-c.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dynamics in One Dimension</title>
      <link>https://boyoon-c.github.io/posts/23/</link>
      <pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/23/</guid>
      <description>Consider a law of motion for the Solow growth model, in which the trajectory of capital is determined non-linearly:
$$ k_{t+1} = Ask_{t}^\alpha + (1-\delta)k_t $$
Here \(k\) is capital stock, and \([A,s, \alpha, \delta] \) are positive parameters.
The following code excerpts are from julia.quantecon.org.
g(k;p) is a function that represents the capital transition function, given the parameter set p and argument k.
g(k; p) = p.A * p.s * k^p.</description>
    </item>
    
    <item>
      <title>Ephemeral</title>
      <link>https://boyoon-c.github.io/posts/22/</link>
      <pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/22/</guid>
      <description>Though it is true that we all die at some point, we often forget this truth. Maybe because thinking about it makes us too sad, makes us too depressed, makes us too afraid or other times too reckless. So most of the times, we tend to live and make decisions as if we are immortal.
Faced with the sudden deaths of our acquaintances is when this uncomfortable truth suddenly reveals itself, sticks its heavy head out, as if scolding us for overlooking their existence.</description>
    </item>
    
    <item>
      <title>Julia Essentials</title>
      <link>https://boyoon-c.github.io/posts/21/</link>
      <pubDate>Sat, 22 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/21/</guid>
      <description>; We add ; to suppress output returned. For example let&amp;rsquo;s compare two codes with and without ; at the end. x=2 would return 2 in the console as an output while x=2; will not return anything in the console.
enumerate() enumerate() returns both the index and the value of an element in an array.
collect(enumerate(countries)) Output:
(1, &amp;#34;Korea&amp;#34;) (2, &amp;#34;Japan&amp;#34;) (3, &amp;#34;China&amp;#34;) countries = (&amp;#34;Korea&amp;#34;, &amp;#34;Japan&amp;#34;, &amp;#34;China&amp;#34;) for (index, country) in enumerate(countries) println(&amp;#34;Country $(country) in index $(index)&amp;#34;) end Output:</description>
    </item>
    
    <item>
      <title>Matrix Decomposition</title>
      <link>https://boyoon-c.github.io/posts/20/</link>
      <pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/20/</guid>
      <description>Matrix decomposition example Let N be the number of possible simulated paths, T be the number of time periods, and P be the number of parameters to estimate. For now, let&amp;rsquo;s suppose that N = 4, T=2 and P=2. Below is an example with T-by-N matrix. The rows indicates different time periods, and the columns indicate different simulated paths \(n \in \{1,2,3,4\} \). For example,
$$ A = \begin{bmatrix} a_{11}\theta + b_{11}\rho &amp;amp; a_{12}\theta + b_{12}\rho &amp;amp; a_{13}\theta + b_{13}\rho &amp;amp; a_{14}\theta + b_{14}\rho \newline \beta(a_{21}\theta + b_{21}\rho) &amp;amp; \beta(a_{22}\theta + b_{22}\rho) &amp;amp; \beta(a_{23}\theta + b_{23}\rho) &amp;amp; \beta(a_{24}\theta + b_{24}\rho) \end{bmatrix} \newline $$ When n =1, $$ \begin{bmatrix} 1 &amp;amp; \beta \end{bmatrix} \begin{bmatrix} a_{11} &amp;amp; b_{11} \newline a_{21} &amp;amp; b_{21} \end{bmatrix} \begin{bmatrix} \theta \newline \rho \end{bmatrix} $$ When n =2, $$ \begin{bmatrix} 1 &amp;amp; \beta \end{bmatrix} \begin{bmatrix} a_{12} &amp;amp; b_{12} \newline a_{22} &amp;amp; b_{22} \end{bmatrix} \begin{bmatrix} \theta \newline \rho \end{bmatrix} $$ When n =3, $$ \begin{bmatrix} 1 &amp;amp; \beta \end{bmatrix} \begin{bmatrix} a_{13} &amp;amp; b_{13} \newline a_{23} &amp;amp; b_{23} \end{bmatrix} \begin{bmatrix} \theta \newline \rho \end{bmatrix} $$ When n =4, $$ \begin{bmatrix} 1 &amp;amp; \beta \end{bmatrix} \begin{bmatrix} a_{14} &amp;amp; b_{14} \newline a_{24} &amp;amp; b_{24} \end{bmatrix} \begin{bmatrix} \theta \newline \rho \end{bmatrix} $$</description>
    </item>
    
    <item>
      <title>Quantitative Economics with Julia</title>
      <link>https://boyoon-c.github.io/posts/19/</link>
      <pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/19/</guid>
      <description>for loop in, ∈, = Below three for loops return the same output. Note that in, ∈, = can be used interchangeably to indicate that i loops over the following array, 1:2:10 which indicates that the array ranges from 1 to 10 with an increment of 2.
for i in 1:2:10 println(i) end for i ∈ 1:2:10 println(i) end for i = 1:2:10 println(i) end Output:
1 3 5 7 9 eachindex I also introduce in this post eachindex, which returns the index of a given vector.</description>
    </item>
    
    <item>
      <title>DataFrames.jl (3) and Pipe</title>
      <link>https://boyoon-c.github.io/posts/16/</link>
      <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/16/</guid>
      <description>Selecting and transforming columns When selecting variables of a data frame, we do add : to indicate that it&amp;rsquo;s a variable name. Thus for example, if we want to select column with variable x, we use :x inside select().
First let&amp;rsquo;s construct some 500 by 3 dimensional data frame called df that contains three columns each of which has name of A, B, and C.
using DataFrames df = DataFrame( A=1:2:1000, B= repeat(1:10, inner=50), C= 1:500) Each of below codes produces 500 by 1 dataframe, a data frame that only contains column A.</description>
    </item>
    
    <item>
      <title>AI and Workforce Competition</title>
      <link>https://boyoon-c.github.io/posts/18/</link>
      <pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/18/</guid>
      <description>Some argue that those who fail to utilize AI cannot keep up with their competitors. But is that necessarily true?
To answer this question, we need to consider how AI affects workforce competition. Suppose that two candidates, one with high-skills (referred to as worker A) and the other with low-skills (referred to as worker B) are competing for a job at some company C. Now that AI is readily available to both workers, they would both use it, assuming that AI improves their competitiveness.</description>
    </item>
    
    <item>
      <title>SymPy.jl</title>
      <link>https://boyoon-c.github.io/posts/17/</link>
      <pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/17/</guid>
      <description>SymPy.jl When functions are linear in parameters, we can decompose a matrix of polynomials into a matrix of coefficients and a matrix of variables. To achieve this, we can use the SymPy package.
First we need to ensure that Julia recognizes variables and treats them as symbols.
using SymPy x, y = symbols(&amp;#34;x, y&amp;#34;) Then we can simply invoke thecoeff() method to extract coefficients from the polynomials.
p = x + 0.</description>
    </item>
    
    <item>
      <title>Dynamic programming (4) Example</title>
      <link>https://boyoon-c.github.io/posts/13/</link>
      <pubDate>Sat, 15 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/13/</guid>
      <description>Consider a simple consumption-saving model, where action (a) is defined by the amount of savings each period, state (s) defined by the current stock, reward be the utility which depends on consumption (c=s-a). Suppose that state is updated where the output is drawn from a uniform distribution on {0, . . . , B}. Let the global upper bound of storage be M.
State space State space is \(n = M+B+1\) dimension.</description>
    </item>
    
    <item>
      <title>DataFrames.jl (2)</title>
      <link>https://boyoon-c.github.io/posts/15/</link>
      <pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/15/</guid>
      <description>Taking a Subset We can subset a dataframe using index. For example we can subset specific columns and rows by following codes.
# column subset (subset df to only include column A and C) df[:, [:A, :C]] # row subset (subset df to only include 1st, 3rd, and 5th rows) df[[1,3,5], :] We could also use some selectors such as Not, Between, Colsand All. Following code removes columns whose names match r&amp;quot;x&amp;quot;.</description>
    </item>
    
    <item>
      <title>DataFrames.jl (1)</title>
      <link>https://boyoon-c.github.io/posts/14/</link>
      <pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/14/</guid>
      <description>Create dataframe To create a dataframe, simply use DataFrame function after loding DataFrames.jl.
Following code produces a dataframe composed of three variables, A, B, and C, each of which has 500 rows. Each row of column A increments by 2 starting from integer 1. Column B repeats 50 times of each integer starting from 1. Coumn C lists integers from 1 to 500.
using DataFrames df = DataFrame(A=1:2:1000, B= repeat(1:10, inner=50), C= 1:500) first, last The first and last functions act as head and tail function in R, which allow us to view the first or the last couple of rows of the dataset.</description>
    </item>
    
    <item>
      <title>Dynamic programming (3) Discrete DPs</title>
      <link>https://boyoon-c.github.io/posts/12/</link>
      <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/12/</guid>
      <description>Let \(s_t\) denotes the state variable, \(a_t\) denotes the action, \(\beta\) denotes a discount factor. Note that \(r(a_t, s_t)\) can be interpreted as a current reward that is a function of the current action and current state.</description>
    </item>
    
    <item>
      <title>Dynamic programming (2) Rewards</title>
      <link>https://boyoon-c.github.io/posts/11/</link>
      <pubDate>Sun, 09 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/11/</guid>
      <description>Rewards The goal of the agent is to maximize the cumulative sum of the rewards of the long-run. The rewards could be arbitrarily chosen number that summarizes how one wants the agent to behave under specific state, action, and subsequent state.
The rewards function, formally represented by \(R(s)\) or \(R(s,a)\), or \(R(s, a, s^\prime)\) can depend on current state, the subsequent state as well as the action taken by the agent taken in the current state.</description>
    </item>
    
    <item>
      <title>Some random thoughts</title>
      <link>https://boyoon-c.github.io/posts/10/</link>
      <pubDate>Fri, 07 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/10/</guid>
      <description>Some random thoughts</description>
    </item>
    
    <item>
      <title>Dynamic programming (1) MDP</title>
      <link>https://boyoon-c.github.io/posts/09/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/09/</guid>
      <description>The agent and the environment In finite Markov Decision Process (MDP), we have three sets, a set of states, a set of actions, and a set of rewards.
The learner or decision maker is called agent and the outside system that the agent interacts with is called environment. Everyperiod, the agent takes actions and correspondingly the environment reacts to produce new states to the agent.
Each period, the environment presents \(S_t\) from a set \( S\).</description>
    </item>
    
    <item>
      <title>Map and broadcast</title>
      <link>https://boyoon-c.github.io/posts/08/</link>
      <pubDate>Wed, 05 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/08/</guid>
      <description>Map map(f, c...) applies function f to each element of collection c that enter as the the second argument of the map function.
Below two lines of codes produce same output. This means that map also acts as a for loop.
map(x-&amp;gt;x+2, 1:10) [ x + 2 for x=1:10] Output:
10-element Vector{Int64}: 3 4 5 6 7 8 9 10 11 12 The function that enters the first argument of map could take multiple arguments; it could be more than one argument.</description>
    </item>
    
    <item>
      <title>Comprehension</title>
      <link>https://boyoon-c.github.io/posts/07/</link>
      <pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/07/</guid>
      <description>Comprehensions works similar to for loop except that it can be expressed into a single line.
For example, below will iterate the process of summing three variables that takes different integer in a range of 1 and 3. This will produce 27 different cases each of which will be stored in 3x3x3 array.
[ i + j + k for i=1:3, j=1:3, k=1:3 ] Output:
3×3×3 Array{Int64, 3}: [:, :, 1] = 3 4 5 4 5 6 5 6 7 [:, :, 2] = 4 5 6 5 6 7 6 7 8 [:, :, 3] = 5 6 7 6 7 8 7 8 9 </description>
    </item>
    
    <item>
      <title>Optimization Using Julia</title>
      <link>https://boyoon-c.github.io/posts/04/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/04/</guid>
      <description>This post is about optimization using Julia</description>
    </item>
    
    <item>
      <title>What job might not be replaceable by AI? </title>
      <link>https://boyoon-c.github.io/posts/05/</link>
      <pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/05/</guid>
      <description>This post explores jobs that might be hard to be replaced by AI</description>
    </item>
    
    <item>
      <title>Modules in Julia</title>
      <link>https://boyoon-c.github.io/posts/06/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/06/</guid>
      <description>Desc</description>
    </item>
    
    <item>
      <title>For loop, RData, filter, and wsample in Julia</title>
      <link>https://boyoon-c.github.io/posts/03/</link>
      <pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/03/</guid>
      <description>This post is using for loop, importing R object into Julia, using filter to DataFrame-type-object, using wsample to draw values from known probability distribution</description>
    </item>
    
    <item>
      <title>Basics of Julia</title>
      <link>https://boyoon-c.github.io/posts/02/</link>
      <pubDate>Thu, 30 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/02/</guid>
      <description>This post is about basics of Julia. This is an exercise before running the simulation for my job market paper using Julia</description>
    </item>
    
    <item>
      <title>Perfect Prediction?</title>
      <link>https://boyoon-c.github.io/posts/01/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/01/</guid>
      <description>Some random thoughts</description>
    </item>
    
  </channel>
</rss>
