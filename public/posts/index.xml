<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Boyoon&#39;s blog</title>
    <link>https://boyoon-c.github.io/posts/</link>
    <description>Recent content in Posts on Boyoon&#39;s blog</description>
    <image>
      <title>Boyoon&#39;s blog</title>
      <url>https://boyoon-c.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://boyoon-c.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 10 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://boyoon-c.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BLP</title>
      <link>https://boyoon-c.github.io/posts/34/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/34/</guid>
      <description>To be updated </description>
    </item>
    
    <item>
      <title>Datatable basics in R</title>
      <link>https://boyoon-c.github.io/posts/35/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/35/</guid>
      <description>To be updated </description>
    </item>
    
    <item>
      <title>LASSO</title>
      <link>https://boyoon-c.github.io/posts/36/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/36/</guid>
      <description>To be updated </description>
    </item>
    
    <item>
      <title>SQL basics</title>
      <link>https://boyoon-c.github.io/posts/33/</link>
      <pubDate>Fri, 09 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/33/</guid>
      <description>Create database Select columns Select rows Joins </description>
    </item>
    
    <item>
      <title>The McCall Search Model</title>
      <link>https://boyoon-c.github.io/posts/31/</link>
      <pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/31/</guid>
      <description>Set up An agent decides whether to delay her employment later (keep searching) or take the job (settle). An agent&amp;rsquo;s action is binary (keep searching or take the job). If she takes the job, she will get constant wage indefinitely. If she rejects the job, she receives unemployment compensation c and reconsider her choice next period. The probability of observing wage offer is uniformly distributed. There are n states of wages with equal probability.</description>
    </item>
    
    <item>
      <title>Broadcasting in Julia</title>
      <link>https://boyoon-c.github.io/posts/32/</link>
      <pubDate>Thu, 11 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/32/</guid>
      <description>By using Ref(), it protects the object inside it from being iterated over. Supoose we define the following function fun. See the examples below that demonstrate how broadcasting works:
fun(a,x)=a.-x Case 1:
fun.([1,2], [3,4]) Note that without Ref(), both arguments of function fun are interated over from broadcasting. This implies that each element within each argument will be computed element-wise. ([1-3, 2-4])
2-element Vector{Int64}: -2 -2 Case 2:
fun.([1,2], Ref([3,4])) Note that Ref() protects [3,4].</description>
    </item>
    
    <item>
      <title>pop! and push!</title>
      <link>https://boyoon-c.github.io/posts/30/</link>
      <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/30/</guid>
      <description>push! Continuing on previous post, let&amp;rsquo;s start with creating an Dictionary object.
eng2kor=Dict( &amp;#34;one&amp;#34;=&amp;gt;&amp;#34;일&amp;#34;, &amp;#34;two&amp;#34;=&amp;gt;&amp;#34;이&amp;#34;, &amp;#34;three&amp;#34;=&amp;gt;&amp;#34;삼&amp;#34;, &amp;#34;four&amp;#34;=&amp;gt;&amp;#34;사&amp;#34; ) Output:
Dict{String, String} with 4 entries: &amp;#34;two&amp;#34; =&amp;gt; &amp;#34;이&amp;#34; &amp;#34;four&amp;#34; =&amp;gt; &amp;#34;사&amp;#34; &amp;#34;one&amp;#34; =&amp;gt; &amp;#34;일&amp;#34; &amp;#34;three&amp;#34; =&amp;gt; &amp;#34;삼&amp;#34; push! allows us to add one additional key-value pair if the added key is not present in the existing Dictionary, or if it is present, replace existing key with different value.
# replace with existing key with different value push!</description>
    </item>
    
    <item>
      <title>Dictionaries in Julia</title>
      <link>https://boyoon-c.github.io/posts/29/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/29/</guid>
      <description>What comprise Dictionaries? Keys Values Example codes eng2kor=Dict( &amp;#34;one&amp;#34;=&amp;gt;&amp;#34;일&amp;#34;, &amp;#34;two&amp;#34;=&amp;gt;&amp;#34;이&amp;#34;, &amp;#34;three&amp;#34;=&amp;gt;&amp;#34;삼&amp;#34;, &amp;#34;four&amp;#34;=&amp;gt;&amp;#34;사&amp;#34; ) function histogram(s) d = Dict() for c in s if c ∉ keys(d) d[c] = 1 else d[c] += 1 end end d end Output:
Dict{Any, Any} with 3 entries: &amp;#39;보… =&amp;gt; 2 &amp;#39;장… =&amp;gt; 2 &amp;#39;윤… =&amp;gt; 2 Reference https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#_a_dictionary_is_a_mapping</description>
    </item>
    
    <item>
      <title>Multi-threading</title>
      <link>https://boyoon-c.github.io/posts/28/</link>
      <pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/28/</guid>
      <description>How to check the number of threads Threads.nthreads() Output:
8 For me, I have eight threads at my disposal for code execution.
How to check thread id Threads.threadid() Output:
1 Since we are on the master thread, Threads.threadid() will return 1.
@threads Macro Below we create a with 10 elements in it, then use multi-threads to put thread id used to process the given for loop. To use multi-thread, we use Threads.</description>
    </item>
    
    <item>
      <title>reshape and permutedims</title>
      <link>https://boyoon-c.github.io/posts/27/</link>
      <pubDate>Tue, 02 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/27/</guid>
      <description>The elements in the reshaped matrix will always be orderded column-wise. For example, consider the following code:
using LinearAlgra C = [1,2,3,4,5,6] reshape(C, (2,3)) Output:
2×3 Matrix{Int64}: 1 3 5 2 4 6 Notice that number 2 is placed in the first column of the second row, instead of the second column of the first row.
Suppose that we want to create a 2-by-3 matrix where the first row is initially filled and the second row is filled afterwards.</description>
    </item>
    
    <item>
      <title>Argmax</title>
      <link>https://boyoon-c.github.io/posts/26/</link>
      <pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/26/</guid>
      <description>Today I explore argmax and argmin function defined in Base package.
armax returns a maximal index, while argmin returns a minimal index.
A = [1 2; 3 4] argmax(A) Output:
CartesianIndex(2, 2) B=[-1 2; 10 -10] argmax(B) Output:
CartesianIndex(2, 1) argmin(B) Output:
CartesianIndex(2, 2) argmax can have a function as the first argument (say f) and the domain of the function (say x) as the second argument and it will still find a value of x that maximizes f(x) .</description>
    </item>
    
    <item>
      <title>Markov Chain (example codes)</title>
      <link>https://boyoon-c.github.io/posts/25/</link>
      <pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/25/</guid>
      <description>Simulation of Markov Chain The following code excerpts are from julia.quantecon.org. I added explanations to each line of codes.
function mc_sample_path(P; init=1, sample_size=1000) # transition matrix, P, should be a square matrix @assert size(P)[1] == size(P)[2] # N be the number of rows of P matrix (or the number of initial states) N = size(P)[1] # dists be the state transition probabilities for each initial state; for example dists[1] will be state-transition probabilities of state 1 transitioning to state 1 and 2 respectively dists = [Categorical(P[i, :]) for i in 1:N] # create X that stores samples X = fill(0, sample_size) # put init as the first element of X X[1] = init # loop over from 2 to the `sample_size` that draws randomly of states (either 1 or 2) by the last state&amp;#39;s transition distribution for t in 2:sample_size dist=dists[X[t-1]] X[t]=rand(dist) end return X end P=[0.</description>
    </item>
    
    <item>
      <title>AR(1) model</title>
      <link>https://boyoon-c.github.io/posts/24/</link>
      <pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/24/</guid>
      <description>Suppose we have following AR(1) model (autoregressive model of order 1) defined by: $$ X_{t+1}=aX_t + b+ cW_{t+1} $$ where
\(X_0\) and \(W_{t}\) are independent, [a,b,c] are scalar-valued parameters, the state space is \(\mathbb{R}\), the process \(W_{t}\) is independently distributed and standard normal, and initial condition \(X_0\) is drawn from the normal distribution of mean \(\mu_0\) and standard error of \(\nu_0\). Iterating backward from time \(t\), we have $$ X_t = a^tX_0 + b \sum_{j=0}^{t-1}a^j + c\sum_{j=0}^{t-1}a^jW_{t-j}, $$ which implies that \(X_t\) depends on parameter [a,b,c], initial condition \(X_0\), and the sequence of shocks from period 1 throughout t represented by \(W_1, \cdots, W_t\).</description>
    </item>
    
    <item>
      <title>Dynamics in One Dimension</title>
      <link>https://boyoon-c.github.io/posts/23/</link>
      <pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/23/</guid>
      <description>Consider a law of motion for the Solow growth model, in which the trajectory of capital is determined non-linearly:
$$ k_{t+1} = Ask_{t}^\alpha + (1-\delta)k_t $$
Here \(k\) is capital stock, and \([A,s, \alpha, \delta] \) are positive parameters.
The following code excerpts are from julia.quantecon.org.
g(k;p) is a function that represents the capital transition function, given the parameter set p and argument k.
g(k; p) = p.A * p.s * k^p.</description>
    </item>
    
    <item>
      <title>Ephemeral</title>
      <link>https://boyoon-c.github.io/posts/22/</link>
      <pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/22/</guid>
      <description>Though it is true that we all die at some point, we often forget this truth. Maybe because thinking about it makes us too sad, makes us too depressed, makes us too afraid or other times too reckless. So most of the times, we tend to live and make decisions as if we are immortal.
Faced with the sudden deaths of our acquaintances is when this uncomfortable truth suddenly reveals itself, sticks its heavy head out, as if scolding us for overlooking their existence.</description>
    </item>
    
    <item>
      <title>Julia Essentials</title>
      <link>https://boyoon-c.github.io/posts/21/</link>
      <pubDate>Sat, 22 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/21/</guid>
      <description>; We add ; to suppress output returned. For example let&amp;rsquo;s compare two codes with and without ; at the end. x=2 would return 2 in the console as an output while x=2; will not return anything in the console.
enumerate() enumerate() returns both the index and the value of an element in an array.
collect(enumerate(countries)) Output:
(1, &amp;#34;Korea&amp;#34;) (2, &amp;#34;Japan&amp;#34;) (3, &amp;#34;China&amp;#34;) countries = (&amp;#34;Korea&amp;#34;, &amp;#34;Japan&amp;#34;, &amp;#34;China&amp;#34;) for (index, country) in enumerate(countries) println(&amp;#34;Country $(country) in index $(index)&amp;#34;) end Output:</description>
    </item>
    
    <item>
      <title>Matrix Decomposition</title>
      <link>https://boyoon-c.github.io/posts/20/</link>
      <pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/20/</guid>
      <description>Matrix decomposition example Let N be the number of possible simulated paths, T be the number of time periods, and P be the number of parameters to estimate. For now, let&amp;rsquo;s suppose that N = 4, T=2 and P=2. Below is an example with T-by-N matrix. The rows indicates different time periods, and the columns indicate different simulated paths \(n \in \{1,2,3,4\} \). For example,
$$ A = \begin{bmatrix} a_{11}\theta + b_{11}\rho &amp;amp; a_{12}\theta + b_{12}\rho &amp;amp; a_{13}\theta + b_{13}\rho &amp;amp; a_{14}\theta + b_{14}\rho \newline \beta(a_{21}\theta + b_{21}\rho) &amp;amp; \beta(a_{22}\theta + b_{22}\rho) &amp;amp; \beta(a_{23}\theta + b_{23}\rho) &amp;amp; \beta(a_{24}\theta + b_{24}\rho) \end{bmatrix} \newline $$ When n =1, $$ \begin{bmatrix} 1 &amp;amp; \beta \end{bmatrix} \begin{bmatrix} a_{11} &amp;amp; b_{11} \newline a_{21} &amp;amp; b_{21} \end{bmatrix} \begin{bmatrix} \theta \newline \rho \end{bmatrix} $$ When n =2, $$ \begin{bmatrix} 1 &amp;amp; \beta \end{bmatrix} \begin{bmatrix} a_{12} &amp;amp; b_{12} \newline a_{22} &amp;amp; b_{22} \end{bmatrix} \begin{bmatrix} \theta \newline \rho \end{bmatrix} $$ When n =3, $$ \begin{bmatrix} 1 &amp;amp; \beta \end{bmatrix} \begin{bmatrix} a_{13} &amp;amp; b_{13} \newline a_{23} &amp;amp; b_{23} \end{bmatrix} \begin{bmatrix} \theta \newline \rho \end{bmatrix} $$ When n =4, $$ \begin{bmatrix} 1 &amp;amp; \beta \end{bmatrix} \begin{bmatrix} a_{14} &amp;amp; b_{14} \newline a_{24} &amp;amp; b_{24} \end{bmatrix} \begin{bmatrix} \theta \newline \rho \end{bmatrix} $$</description>
    </item>
    
    <item>
      <title>Quantitative Economics with Julia</title>
      <link>https://boyoon-c.github.io/posts/19/</link>
      <pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/19/</guid>
      <description>for loop in, ∈, = Below three for loops return the same output. Note that in, ∈, = can be used interchangeably to indicate that i loops over the following array, 1:2:10 which indicates that the array ranges from 1 to 10 with an increment of 2.
for i in 1:2:10 println(i) end for i ∈ 1:2:10 println(i) end for i = 1:2:10 println(i) end Output:
1 3 5 7 9 eachindex I also introduce in this post eachindex, which returns the index of a given vector.</description>
    </item>
    
    <item>
      <title>DataFrames.jl (3) and Pipe</title>
      <link>https://boyoon-c.github.io/posts/16/</link>
      <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/16/</guid>
      <description>Selecting and transforming columns When selecting variables of a data frame, we do add : to indicate that it&amp;rsquo;s a variable name. Thus for example, if we want to select column with variable x, we use :x inside select().
First let&amp;rsquo;s construct some 500 by 3 dimensional data frame called df that contains three columns each of which has name of A, B, and C.
using DataFrames df = DataFrame( A=1:2:1000, B= repeat(1:10, inner=50), C= 1:500) Each of below codes produces 500 by 1 dataframe, a data frame that only contains column A.</description>
    </item>
    
    <item>
      <title>AI and Workforce Competition</title>
      <link>https://boyoon-c.github.io/posts/18/</link>
      <pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/18/</guid>
      <description>Some argue that those who fail to utilize AI cannot keep up with their competitors. But is that necessarily true?
To answer this question, we need to consider how AI affects workforce competition. Suppose that two candidates, one with high-skills (referred to as worker A) and the other with low-skills (referred to as worker B) are competing for a job at some company C. Now that AI is readily available to both workers, they would both use it, assuming that AI improves their competitiveness.</description>
    </item>
    
    <item>
      <title>SymPy.jl</title>
      <link>https://boyoon-c.github.io/posts/17/</link>
      <pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/17/</guid>
      <description>SymPy.jl When functions are linear in parameters, we can decompose a matrix of polynomials into a matrix of coefficients and a matrix of variables. To achieve this, we can use the SymPy package.
First we need to ensure that Julia recognizes variables and treats them as symbols.
using SymPy x, y = symbols(&amp;#34;x, y&amp;#34;) Then we can simply invoke thecoeff() method to extract coefficients from the polynomials.
p = x + 0.</description>
    </item>
    
    <item>
      <title>Dynamic programming (4) Example</title>
      <link>https://boyoon-c.github.io/posts/13/</link>
      <pubDate>Sat, 15 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/13/</guid>
      <description>Consider a simple consumption-saving model, where action (a) is defined by the amount of savings each period, state (s) defined by the current stock, reward be the utility which depends on consumption (c=s-a). Suppose that state is updated where the output is drawn from a uniform distribution on {0, . . . , B}. Let the global upper bound of storage be M.
State space State space is \(n = M+B+1\) dimension.</description>
    </item>
    
    <item>
      <title>DataFrames.jl (2)</title>
      <link>https://boyoon-c.github.io/posts/15/</link>
      <pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/15/</guid>
      <description>Taking a Subset We can subset a dataframe using index. For example we can subset specific columns and rows by following codes.
# column subset (subset df to only include column A and C) df[:, [:A, :C]] # row subset (subset df to only include 1st, 3rd, and 5th rows) df[[1,3,5], :] We could also use some selectors such as Not, Between, Colsand All. Following code removes columns whose names match r&amp;quot;x&amp;quot;.</description>
    </item>
    
    <item>
      <title>DataFrames.jl (1)</title>
      <link>https://boyoon-c.github.io/posts/14/</link>
      <pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/14/</guid>
      <description>Create dataframe To create a dataframe, simply use DataFrame function after loding DataFrames.jl.
Following code produces a dataframe composed of three variables, A, B, and C, each of which has 500 rows. Each row of column A increments by 2 starting from integer 1. Column B repeats 50 times of each integer starting from 1. Coumn C lists integers from 1 to 500.
using DataFrames df = DataFrame(A=1:2:1000, B= repeat(1:10, inner=50), C= 1:500) first, last The first and last functions act as head and tail function in R, which allow us to view the first or the last couple of rows of the dataset.</description>
    </item>
    
    <item>
      <title>Dynamic programming (3) Discrete DPs</title>
      <link>https://boyoon-c.github.io/posts/12/</link>
      <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/12/</guid>
      <description>Let \(s_t\) denotes the state variable, \(a_t\) denotes the action, \(\beta\) denotes a discount factor. Note that \(r(a_t, s_t)\) can be interpreted as a current reward that is a function of the current action and current state.</description>
    </item>
    
    <item>
      <title>Dynamic programming (2) Rewards</title>
      <link>https://boyoon-c.github.io/posts/11/</link>
      <pubDate>Sun, 09 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/11/</guid>
      <description>Rewards The goal of the agent is to maximize the cumulative sum of the rewards of the long-run. The rewards could be arbitrarily chosen number that summarizes how one wants the agent to behave under specific state, action, and subsequent state.
The rewards function, formally represented by \(R(s)\) or \(R(s,a)\), or \(R(s, a, s^\prime)\) can depend on current state, the subsequent state as well as the action taken by the agent taken in the current state.</description>
    </item>
    
    <item>
      <title>Some random thoughts</title>
      <link>https://boyoon-c.github.io/posts/10/</link>
      <pubDate>Fri, 07 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/10/</guid>
      <description>Some random thoughts</description>
    </item>
    
    <item>
      <title>Dynamic programming (1) MDP</title>
      <link>https://boyoon-c.github.io/posts/09/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/09/</guid>
      <description>The agent and the environment In finite Markov Decision Process (MDP), we have three sets, a set of states, a set of actions, and a set of rewards.
The learner or decision maker is called agent and the outside system that the agent interacts with is called environment. Everyperiod, the agent takes actions and correspondingly the environment reacts to produce new states to the agent.
Each period, the environment presents \(S_t\) from a set \( S\).</description>
    </item>
    
    <item>
      <title>Map and broadcast</title>
      <link>https://boyoon-c.github.io/posts/08/</link>
      <pubDate>Wed, 05 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/08/</guid>
      <description>Map map(f, c...) applies function f to each element of collection c that enter as the the second argument of the map function.
Below two lines of codes produce same output. This means that map also acts as a for loop.
map(x-&amp;gt;x+2, 1:10) [ x + 2 for x=1:10] Output:
10-element Vector{Int64}: 3 4 5 6 7 8 9 10 11 12 The function that enters the first argument of map could take multiple arguments; it could be more than one argument.</description>
    </item>
    
    <item>
      <title>Comprehension</title>
      <link>https://boyoon-c.github.io/posts/07/</link>
      <pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/07/</guid>
      <description>Comprehensions works similar to for loop except that it can be expressed into a single line.
For example, below will iterate the process of summing three variables that takes different integer in a range of 1 and 3. This will produce 27 different cases each of which will be stored in 3x3x3 array.
[ i + j + k for i=1:3, j=1:3, k=1:3 ] Output:
3×3×3 Array{Int64, 3}: [:, :, 1] = 3 4 5 4 5 6 5 6 7 [:, :, 2] = 4 5 6 5 6 7 6 7 8 [:, :, 3] = 5 6 7 6 7 8 7 8 9 </description>
    </item>
    
    <item>
      <title>Optimization Using Julia</title>
      <link>https://boyoon-c.github.io/posts/04/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/04/</guid>
      <description>This post is about optimization using Julia</description>
    </item>
    
    <item>
      <title>What job might not be replaceable by AI? </title>
      <link>https://boyoon-c.github.io/posts/05/</link>
      <pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/05/</guid>
      <description>This post explores jobs that might be hard to be replaced by AI</description>
    </item>
    
    <item>
      <title>Modules in Julia</title>
      <link>https://boyoon-c.github.io/posts/06/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/06/</guid>
      <description>Desc</description>
    </item>
    
    <item>
      <title>For loop, RData, filter, and wsample in Julia</title>
      <link>https://boyoon-c.github.io/posts/03/</link>
      <pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/03/</guid>
      <description>This post is using for loop, importing R object into Julia, using filter to DataFrame-type-object, using wsample to draw values from known probability distribution</description>
    </item>
    
    <item>
      <title>Basics of Julia</title>
      <link>https://boyoon-c.github.io/posts/02/</link>
      <pubDate>Thu, 30 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/02/</guid>
      <description>This post is about basics of Julia. This is an exercise before running the simulation for my job market paper using Julia</description>
    </item>
    
    <item>
      <title>Perfect Prediction?</title>
      <link>https://boyoon-c.github.io/posts/01/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://boyoon-c.github.io/posts/01/</guid>
      <description>Some random thoughts</description>
    </item>
    
  </channel>
</rss>
